{"version":3,"sources":["turbopack:///[project]/src/lib/workers.ts","turbopack:///[project]/src/jobs/processors/default-processor.ts","turbopack:///[project]/src/jobs/processors/communications-processor.ts","turbopack:///[project]/src/lib/queue-init.ts","turbopack:///[project]/src/jobs/schedulers/job-scheduler.ts","turbopack:///[project]/src/jobs/cron/cron-jobs.ts"],"sourcesContent":["import { Worker } from 'bullmq';\nimport { getRedis } from './redis';\nimport { QUEUE_NAMES } from './queues';\n\n// Worker instances\nlet defaultWorker: Worker | null = null;\nlet communicationsWorker: Worker | null = null;\n\n/**\n * Processors for different queues\n * Import your job processors here\n */\nimport { processDefaultJob } from '../jobs/processors/default-processor';\nimport { processCommunicationsJob } from '../jobs/processors/communications-processor';\n\n/**\n * Get or create the default worker instance\n */\nexport const getDefaultWorker = (): Worker => {\n  if (!defaultWorker) {\n    defaultWorker = new Worker(\n      QUEUE_NAMES.DEFAULT,\n      async (job) => {\n        return await processDefaultJob(job);\n      },\n      {\n        connection: getRedis(),\n        concurrency: 5, // Process 5 jobs concurrently\n      }\n    );\n\n    // Error handling\n    defaultWorker.on('failed', (job, err) => {\n      console.error(`Default queue job ${job?.id} failed:`, err);\n    });\n\n    defaultWorker.on('completed', (job) => {\n      console.log(`Default queue job ${job.id} completed`);\n    });\n  }\n  return defaultWorker;\n};\n\n/**\n * Get or create the communications worker instance\n */\nexport const getCommunicationsWorker = (): Worker => {\n  if (!communicationsWorker) {\n    communicationsWorker = new Worker(\n      QUEUE_NAMES.COMMUNICATIONS,\n      async (job) => {\n        return await processCommunicationsJob(job);\n      },\n      {\n        connection: getRedis(),\n        concurrency: 3, // Process 3 communications jobs concurrently\n      }\n    );\n\n    // Error handling\n    communicationsWorker.on('failed', (job, err) => {\n      console.error(`Communications queue job ${job?.id} failed:`, err);\n    });\n\n    communicationsWorker.on('completed', (job) => {\n      console.log(`Communications queue job ${job.id} completed`);\n    });\n  }\n  return communicationsWorker;\n};\n\n/**\n * Initialize all workers\n */\nexport const initializeWorkers = (): void => {\n  getDefaultWorker();\n  getCommunicationsWorker();\n  console.log('All workers initialized');\n};\n\n/**\n * Close all workers\n */\nexport const closeWorkers = async (): Promise<void> => {\n  if (defaultWorker) {\n    await defaultWorker.close();\n    defaultWorker = null;\n  }\n  if (communicationsWorker) {\n    await communicationsWorker.close();\n    communicationsWorker = null;\n  }\n};\n\n","import { Job } from 'bullmq';\n\nexport interface DefaultJobData {\n  type: string;\n  [key: string]: any;\n}\n\n/**\n * Process default queue jobs\n */\nexport async function processDefaultJob(job: Job<DefaultJobData>): Promise<any> {\n  const { type, ...data } = job.data;\n\n  console.log(`Processing default job: ${type}`, { jobId: job.id, data });\n\n  // Route to specific job handler based on type\n  switch (type) {\n    case 'example-job':\n      return await handleExampleJob(data);\n    // Add more job types here\n    default:\n      throw new Error(`Unknown job type: ${type}`);\n  }\n}\n\n/**\n * Example job handler\n */\nasync function handleExampleJob(data: any): Promise<any> {\n  // Implement your job logic here\n  console.log('Processing example job with data:', data);\n  return { success: true };\n}\n\n\n","import { Job } from 'bullmq';\n\nexport interface CommunicationsJobData {\n  type: string;\n  [key: string]: any;\n}\n\n/**\n * Process communications queue jobs\n */\nexport async function processCommunicationsJob(\n  job: Job<CommunicationsJobData>\n): Promise<any> {\n  const { type, ...data } = job.data;\n\n  console.log(`Processing communications job: ${type}`, { jobId: job.id, data });\n\n  // Route to specific job handler based on type\n  switch (type) {\n    case 'send-email':\n      return await handleSendEmail(data);\n    case 'send-notification':\n      return await handleSendNotification(data);\n    // Add more communication job types here\n    default:\n      throw new Error(`Unknown communications job type: ${type}`);\n  }\n}\n\n/**\n * Send email job handler\n */\nasync function handleSendEmail(data: any): Promise<any> {\n  // Implement email sending logic here\n  console.log('Sending email with data:', data);\n  return { success: true, message: 'Email sent' };\n}\n\n/**\n * Send notification job handler\n */\nasync function handleSendNotification(data: any): Promise<any> {\n  // Implement notification sending logic here\n  console.log('Sending notification with data:', data);\n  return { success: true, message: 'Notification sent' };\n}\n\n\n","/**\n * Initialize queues and workers\n * This should be called when the application starts\n */\nimport { initializeWorkers } from './workers';\nimport { initializeCronJobs } from '@/jobs/cron/cron-jobs';\n\nlet initialized = false;\n\nexport async function initializeQueueSystem(): Promise<void> {\n  if (initialized) {\n    console.log('Queue system already initialized');\n    return;\n  }\n\n  try {\n    // Initialize workers to process jobs\n    initializeWorkers();\n\n    // Initialize cron jobs\n    await initializeCronJobs();\n\n    initialized = true;\n    console.log('Queue system initialized successfully');\n  } catch (error) {\n    console.error('Error initializing queue system:', error);\n    throw error;\n  }\n}\n\n/**\n * Cleanup function to close all connections\n */\nexport async function cleanupQueueSystem(): Promise<void> {\n  const { closeWorkers } = await import('./workers');\n  const { closeQueues } = await import('./queues');\n  const { closeRedis } = await import('./redis');\n\n  await closeWorkers();\n  await closeQueues();\n  await closeRedis();\n\n  initialized = false;\n  console.log('Queue system cleaned up');\n}\n\n\n","import { Queue } from 'bullmq';\nimport { getDefaultQueue, getCommunicationsQueue, QUEUE_NAMES } from '@/lib/queues';\n\n/**\n * Schedule a job to run at a specific time\n */\nexport interface ScheduleJobOptions {\n  queueName?: keyof typeof QUEUE_NAMES;\n  delay?: number; // Delay in milliseconds\n  jobId?: string; // Optional custom job ID\n  attempts?: number; // Number of retry attempts\n  backoff?: {\n    type: 'fixed' | 'exponential';\n    delay: number;\n  };\n}\n\n/**\n * Schedule a job to run at a specific date/time\n */\nexport async function scheduleJob<T = any>(\n  jobType: string,\n  data: T,\n  scheduledTime: Date,\n  options: ScheduleJobOptions = {}\n): Promise<string> {\n  const { queueName = 'DEFAULT', jobId, attempts = 3, backoff } = options;\n  \n  const queue = queueName === 'COMMUNICATIONS' \n    ? getCommunicationsQueue() \n    : getDefaultQueue();\n\n  // Calculate delay in milliseconds\n  const now = new Date();\n  const delay = scheduledTime.getTime() - now.getTime();\n\n  if (delay < 0) {\n    throw new Error('Scheduled time must be in the future');\n  }\n\n  const job = await queue.add(\n    jobType,\n    { type: jobType, ...data },\n    {\n      jobId,\n      delay,\n      attempts,\n      backoff: backoff || {\n        type: 'exponential',\n        delay: 2000, // 2 seconds\n      },\n    }\n  );\n\n  return job.id!;\n}\n\n/**\n * Schedule a job with a delay (in milliseconds)\n */\nexport async function scheduleJobWithDelay<T = any>(\n  jobType: string,\n  data: T,\n  delayMs: number,\n  options: ScheduleJobOptions = {}\n): Promise<string> {\n  const scheduledTime = new Date(Date.now() + delayMs);\n  return scheduleJob(jobType, data, scheduledTime, options);\n}\n\n/**\n * Add a job to queue immediately\n */\nexport async function addJob<T = any>(\n  jobType: string,\n  data: T,\n  options: ScheduleJobOptions = {}\n): Promise<string> {\n  const { queueName = 'DEFAULT', jobId, attempts = 3, backoff } = options;\n  \n  const queue = queueName === 'COMMUNICATIONS' \n    ? getCommunicationsQueue() \n    : getDefaultQueue();\n\n  const job = await queue.add(\n    jobType,\n    { type: jobType, ...data },\n    {\n      jobId,\n      attempts,\n      backoff: backoff || {\n        type: 'exponential',\n        delay: 2000,\n      },\n    }\n  );\n\n  return job.id!;\n}\n\n/**\n * Schedule a recurring job (cron-like)\n */\nexport async function scheduleRecurringJob<T = any>(\n  jobType: string,\n  data: T,\n  cronPattern: string, // e.g., \"0 0 * * *\" for daily at midnight\n  options: ScheduleJobOptions = {}\n): Promise<string> {\n  const { queueName = 'DEFAULT', jobId } = options;\n  \n  const queue = queueName === 'COMMUNICATIONS' \n    ? getCommunicationsQueue() \n    : getDefaultQueue();\n\n  const job = await queue.add(\n    jobType,\n    { type: jobType, ...data },\n    {\n      jobId,\n      repeat: {\n        pattern: cronPattern,\n      },\n      removeOnComplete: {\n        age: 24 * 3600, // Keep completed jobs for 24 hours\n        count: 1000, // Keep last 1000 completed jobs\n      },\n    }\n  );\n\n  return job.id!;\n}\n\n\n","import { scheduleRecurringJob } from '../schedulers/job-scheduler';\n\n/**\n * Initialize all cron jobs\n * This should be called when the application starts\n */\nexport async function initializeCronJobs(): Promise<void> {\n  console.log('Initializing cron jobs...');\n\n  // Example: Daily cleanup job at midnight\n  // await scheduleRecurringJob(\n  //   'daily-cleanup',\n  //   {},\n  //   '0 0 * * *', // Every day at midnight\n  //   { queueName: 'DEFAULT' }\n  // );\n\n  // Example: Send daily digest emails at 9 AM\n  // await scheduleRecurringJob(\n  //   'send-daily-digest',\n  //   {},\n  //   '0 9 * * *', // Every day at 9 AM\n  //   { queueName: 'COMMUNICATIONS' }\n  // );\n\n  // Example: Weekly report every Monday at 8 AM\n  // await scheduleRecurringJob(\n  //   'weekly-report',\n  //   {},\n  //   '0 8 * * 1', // Every Monday at 8 AM\n  //   { queueName: 'DEFAULT' }\n  // );\n\n  console.log('Cron jobs initialized');\n}\n\n/**\n * Register a new cron job\n * Use this function to add cron jobs dynamically\n */\nexport async function registerCronJob(\n  jobType: string,\n  data: any,\n  cronPattern: string,\n  queueName: 'DEFAULT' | 'COMMUNICATIONS' = 'DEFAULT'\n): Promise<string> {\n  return scheduleRecurringJob(jobType, data, cronPattern, { queueName });\n}\n\n\n"],"names":[],"mappings":"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"}